class Solution 
{
public:
    /*解法1：位运算， 如果 a + b 的二进制运算无进位，则 a ^ b 则为结果
    例如 21 + 8 = 29   
        10101 ^ 01000 = 11101
    但如果 a + b 的二进制运算存在进位，则 a ^ b 还需要加上进位，且进位结果为 (a & b) << 1
    例如 12 + 4 = 16
        1100 ^ 0100 = 1000
        1100 & 0100 = 0100,  0100 << 1 = 1000
        1000 ^ 1000 = 0000, (1000 & 1000) << 1 = 10000
        0000 ^ 10000 = 10000
    因而，设 a ^ b = s, (a & b) << 1 = n
    从而 a + b = s + n （循坏的过程，直到 n = 0）
    */
    int add(int a, int b) 
    {
        while (b)
        {
            // c++ 中逻辑位移 与算术位移共享同一个运算符，对于逻辑位移则需要转换为 unsigned int
            int n = (unsigned int)(a & b) << 1; 
            a ^= b;
            b = n;
        }

        return a;
    }
};